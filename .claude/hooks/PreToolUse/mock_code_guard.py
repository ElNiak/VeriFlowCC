# tools/hooks/mock_code_guard.py
# Purpose: Prevent introducing mocks/test doubles & bulky inline fixtures in code/tests generated by Claude-code.
# Strategy: Inspect content of Write/Edit/MultiEdit (and common inline Bash writes) for language-specific mock APIs
#           and deny according to policy. Encourage DI, factories, Testcontainers, property-based tests instead.

from __future__ import annotations
import ast
import json
import os
import re
import shlex
import sys
import fnmatch
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple

POLICY_FILE = Path(".claude/code_policy.json")

DEFAULT_POLICY: Dict[str, Any] = {
    # Where this policy applies
    "blockInTests": True,      # deny mock usage under tests/**
    "blockInSrc": True,        # deny mock usage under src/** and other code dirs
    # Allowed directories (overrides blocks)
    "allowDirs": [],
    # Allowed filename patterns (overrides blocks)
    "allowNameGlobs": [],
    # Language detection by file extension
    "langByExt": {
        ".py": "python", ".pyi": "python",
        ".js": "javascript", ".jsx": "javascript", ".ts": "javascript", ".tsx": "javascript",
        ".java": "java", ".kt": "kotlin", ".kts": "kotlin",
        ".cs": "csharp", ".go": "go", ".rs": "rust"
    },
    # Mock/test-double indicators (case-insensitive regex, per language)
    "mockApiPatterns": {
        "python": [
            r"\bfrom\s+unittest\s+import\s+mock\b",
            r"\bfrom\s+unittest\.mock\s+import\b",
            r"\bimport\s+unittest\.mock\b",
            r"\b(MagicMock|Mock|AsyncMock|create_autospec)\s*\(",
            r"\b@patch\(",
            r"\bpatch\(",
            r"\bmocker\.",            # pytest-mock fixture
            r"\bfaker\.", r"\bFaker\(" # data fakers
        ],
        "javascript": [
            r"\bjest\.mock\(", r"\bvi\.mock\(", r"\bjest\.fn\(", r"\bvi\.fn\(",
            r"\bsinon\.(stub|fake|mock)\(", r"\bnock\(", r"\bmsw\b", r"\bproxyquire\b", r"\brewiremock\b",
            r"\btd\.(replace|when|verify)\(",  # testdouble
            r"\bfaker\.", r"\@faker-js\/faker"
        ],
        "java": [
            r"\borg\.mockito\b", r"\bMockito\.", r"\b@Mock\b", r"\bwhen\(", r"\bgiven\(", r"\bBDDMockito\b",
            r"\bwiremock\b"
        ],
        "kotlin": [
            r"\bio\.mockk\b", r"\bmockk<", r"\bevery\s*\{", r"\bverify\s*\{"
        ],
        "csharp": [
            r"\busing\s+Moq;", r"\bnew\s+Mock<", r"\bSubstitute\.For<", r"\bNSubstitute\b", r"\bFakeItEasy\b"
        ],
        "go": [
            r"\bgithub\.com/golang/mock/gomock\b", r"\bgomock\.NewController\(", r"\bgithub\.com/stretchr/testify/mock\b"
        ],
        "rust": [
            r"\bmockall(::|::prelude::)", r"\bmockito::", r"#\[automock\]"
        ]
    },
    # Treat these directories as tests (deny if blockInTests)
    "testsDirs": ["tests/**", "test/**", "spec/**"],
    # Treat these directories as code (deny if blockInSrc)
    "srcDirs": ["src/**", "lib/**", "app/**", "cmd/**", "internal/**", "pkg/**"],
    # Emergency bypass env
    "bypassEnv": "CLAUDE_ALLOW_MOCK_CODE",
    # Include brief human suggestion in denies
    "includeSuggestion": True
}

# ---------- config helpers ----------

def _read_json(path: Path) -> Dict[str, Any]:
    try:
        if path.is_file():
            return json.loads(path.read_text())
    except Exception:
        pass
    return {}

def _env_list(name: str) -> Optional[List[str]]:
    v = os.getenv(name)
    if not v:
        return None
    return [x.strip() for x in v.split(",") if x.strip()]

def load_policy() -> Dict[str, Any]:
    p = dict(DEFAULT_POLICY)
    p.update(_read_json(POLICY_FILE))
    # env overrides
    for key, envn in [
        ("allowDirs", "CLAUDE_CODE_ALLOW_DIRS"),
        ("allowNameGlobs", "CLAUDE_CODE_ALLOW_NAMES"),
        ("testsDirs", "CLAUDE_CODE_TESTS_DIRS"),
        ("srcDirs", "CLAUDE_CODE_SRC_DIRS"),
    ]:
        lst = _env_list(envn)
        if lst is not None:
            p[key] = lst
    e = os.getenv("CLAUDE_CODE_BLOCK_IN_TESTS");  p["blockInTests"] = p["blockInTests"] if e is None else e not in ("0","false","False")
    e = os.getenv("CLAUDE_CODE_BLOCK_IN_SRC");    p["blockInSrc"]   = p["blockInSrc"] if e is None else e not in ("0","false","False")
    return p

# ---------- path & env utils ----------

def project_root() -> Path:
    return Path(os.getenv("CLAUDE_PROJECT_DIR") or Path.cwd()).resolve()

def norm_path(p: str) -> Path:
    root = project_root()
    abs_p = (root / p).resolve()
    if not str(abs_p).startswith(str(root)):
        raise ValueError(f"path escapes project root: {p}")
    return abs_p

def relpath(p: Path) -> str:
    return p.relative_to(project_root()).as_posix()

def any_glob_ci(s: str, globs: List[str]) -> bool:
    ss = s.lower()
    return any(fnmatch.fnmatchcase(ss, g.lower()) for g in globs or [])

def in_any(rel: str, globs: List[str]) -> bool:
    return any_glob_ci(rel, globs)

def language_of(path: Path, lang_by_ext: Dict[str,str]) -> Optional[str]:
    return lang_by_ext.get(path.suffix.lower())

# ---------- extract content from tools ----------

def extract_write_pairs(payload: Any) -> List[Tuple[str, str]]:
    pairs: List[Tuple[str, str]] = []
    def walk(x: Any):
        if isinstance(x, dict):
            if "path" in x and isinstance(x["path"], str) and "content" in x and isinstance(x["content"], str):
                pairs.append((x["path"], x["content"]))
            for v in x.values():
                walk(v)
        elif isinstance(x, list):
            for it in x:
                walk(it)
    walk(payload)
    # Keep last per path
    seen: Set[str] = set(); out: List[Tuple[str, str]] = []
    for path, content in pairs[::-1]:
        if path not in seen:
            out.append((path, content)); seen.add(path)
    return list(reversed(out))

HEREDOC_RE = re.compile(r"<<-?\s*(['\"]?)(?P<eof>\w+)\1\s*(?P<body>.*?)(?:\n)(?P=eof)\b", re.DOTALL)
ECHO_REDIRECT_RE = re.compile(r"""(?:^|\s)(?:echo|printf)\s+(?P<q>['"])(?P<body>.*?)(?<!\\)(?P=q)\s*(?:>>?|>\|)\s*(?P<target>[^;&|]+)""", re.DOTALL)
TEE_RE = re.compile(r"""(?:^|\s)tee\s+(?P<target>[^-\s][^\s;|&]*)""")

def extract_bash_pairs(command: str) -> List[Tuple[str, Optional[str]]]:
    res: List[Tuple[str, Optional[str]]] = []
    for m in ECHO_REDIRECT_RE.finditer(command):
        res.append((m.group("target").strip(), m.group("body")))
    for m in HEREDOC_RE.finditer(command):
        res.append(("", m.group("body")))
    for m in TEE_RE.finditer(command):
        res.append((m.group("target").strip(), None))
    return [(t, b) for (t, b) in res if t or b]

# ---------- detectors ----------

def py_ast_indicators(src: str) -> List[str]:
    """Parse minimal Python AST to catch unittest.mock imports and decorators."""
    found: List[str] = []
    try:
        tree = ast.parse(src)
    except Exception:
        return found
    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for n in node.names:
                if n.name == "unittest.mock":
                    found.append("import unittest.mock")
        if isinstance(node, ast.ImportFrom):
            mod = node.module or ""
            if mod in ("unittest.mock", "unittest"):
                for n in node.names:
                    if n.name.lower() in {"mock","magicmock","patch","asyncmock","create_autospec"}:
                        found.append(f"from {mod} import {n.name}")
        if isinstance(node, ast.Call):
            # decorators @patch(...) appear as ast.Call in FunctionDef.decorator_list; walk covers them
            func = getattr(node.func, "id", None) or getattr(getattr(node.func, "attr", None), "__str__", lambda: None)()
    return list(set(found))

def regex_hits(patterns: List[str], text: str) -> List[str]:
    hits: List[str] = []
    for rx in patterns or []:
        try:
            if re.search(rx, text, re.IGNORECASE):
                hits.append(rx)
        except re.error:
            # ignore invalid regex
            pass
    return hits

def evaluate_pair(path_str: str, content: str, policy: Dict[str, Any]) -> Tuple[bool, str, Dict[str, Any]]:
    abs_p = norm_path(path_str)
    rel = relpath(abs_p)

    # Allow-lists first
    if in_any(rel, policy.get("allowDirs", [])) or any_glob_ci(rel, policy.get("allowNameGlobs", [])):
        return (False, "allowlist", {"path": rel})

    lang = language_of(abs_p, policy.get("langByExt", {}))
    if not lang:
        return (False, "unknown-lang", {"path": rel})

    # Scope rules
    is_test = in_any(rel, policy.get("testsDirs", []))
    is_src  = in_any(rel, policy.get("srcDirs", []))
    if not ((is_test and policy.get("blockInTests", True)) or (is_src and policy.get("blockInSrc", True))):
        return (False, "out-of-scope", {"path": rel})

    patterns = (policy.get("mockApiPatterns", {}) or {}).get(lang, [])
    hits = regex_hits(patterns, content)

    # Python: enrich with AST signals
    if lang == "python":
        hits += py_ast_indicators(content)

    hits = list(set(hits))
    if not hits:
        return (False, "no-mock-detected", {"path": rel})

    # Provide evidence (first N matching lines)
    evidence: List[str] = []
    lines = content.splitlines()
    for idx, line in enumerate(lines, 1):
        if len(evidence) >= 5:
            break
        for rx in patterns:
            try:
                if re.search(rx, line, re.IGNORECASE):
                    evidence.append(f"{idx}: {line.strip()[:200]}")
                    break
            except re.error:
                pass
    suggestion = (
        "Avoid mocks/test doubles. Prefer: (1) dependency injection with thin real adapters, "
        "(2) Testcontainers or ephemeral services for integration tests, "
        "(3) property-based tests (e.g., Hypothesis/fast-check), "
        "(4) small golden tests only for stable public outputs."
        if policy.get("includeSuggestion", True) else ""
    )

    return (True, "mock-api-detected", {
        "path": rel,
        "language": lang,
        "hits": hits[:10],
        "evidence": evidence,
        "suggestion": suggestion
    })

# ---------- report & entry ----------

def deny(reason: str, message: str, data: Dict[str, Any]) -> int:
    payload = {"decision": "deny", "reason": reason, "message": message, "data": data}
    print("BEGIN_HOOK_REPORT", file=sys.stderr)
    print(json.dumps(payload, indent=2), file=sys.stderr)
    print("END_HOOK_REPORT", file=sys.stderr)
    return 2

def allow(reason: str, data: Dict[str, Any]) -> int:
    payload = {"decision": "allow", "reason": reason, "data": data}
    print("BEGIN_HOOK_REPORT"); print(json.dumps(payload, indent=2)); print("END_HOOK_REPORT")
    return 0

def main() -> int:
    policy = load_policy()
    if os.getenv(policy.get("bypassEnv", "CLAUDE_ALLOW_MOCK_CODE")) == "1":
        return allow("bypass", {"note": "mock code guard bypassed via env"})

    try:
        env = json.load(sys.stdin)
    except Exception:
        return 0

    if env.get("hook_event_name") != "PreToolUse":
        return 0

    tool = env.get("tool_name")
    blocked: List[Dict[str, Any]] = []
    checked: List[str] = []

    if tool in ("Write", "Edit", "MultiEdit"):
        for path, content in extract_write_pairs(env.get("tool_input")):
            blocked_flag, reason, details = evaluate_pair(path, content, policy)
            checked.append(path)
            if blocked_flag:
                blocked.append({"reason": reason, **details})

    elif tool == "Bash":
        cmd = (env.get("tool_input") or {}).get("command", "")
        if cmd:
            for target, body in extract_bash_pairs(cmd):
                if not target or body is None:
                    continue
                # Only evaluate if extension maps to a language
                abs_tgt = norm_path(target); rel_tgt = relpath(abs_tgt)
                lang = language_of(abs_tgt, policy.get("langByExt", {}))
                if not lang:
                    continue
                blocked_flag, reason, details = evaluate_pair(rel_tgt, body, policy)
                checked.append(rel_tgt)
                if blocked_flag:
                    blocked.append({"reason": reason, **details})

    if blocked:
        msg = ("Mock/test-double usage is blocked by policy. Update tests to use DI, real lightweight adapters, "
               "ephemeral services (Testcontainers), or property-based tests. See .claude/code_policy.json for overrides.")
        return deny("mock-code-denied", msg, {"blocked": blocked, "checked": checked, "tool": tool})

    return allow("ok", {"checked": checked, "tool": tool})

if __name__ == "__main__":
    sys.exit(main())